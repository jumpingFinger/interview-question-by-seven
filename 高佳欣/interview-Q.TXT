

### JavaScript （前端玩家必备技能）
1. ele.getAttribute('propName') 和 ele.propName区别？？？
相同点：一般都是操作元素的自定义属性

不同点：
=>.propName是把当前元素当作一个普通对象，基于对象键值对的方式，修改当前元素对象的堆内存地址完成的；
getAttribute是把当前元素当作特殊的元素对象处理，直接修改页面中html标签结构。对当前元素自定义属性的操作和页面结构中的DOM结构有映射关系。
=>两种属于独立的运作机制，不能混淆使用
基于.propName设置的属性用getAttribute获取为undefined；基于getAttribute设置的属性用对象键值对方式获取结果为null


2. mouseover和mouseenter的区别
相同点：都是鼠标事件行为

不同点：
mouseover：鼠标滑到元素上，只要鼠标在上面就会触发，存在冒泡传播机制
mouseenter：鼠标从父元素进入子元素，事件的冒泡传播机制被阻止


3. 什么是事件代理
也叫事件委托，即，基于冒泡传播机制，把事件行为加到父元素之上，相关子元素的事件行为都被触发

应用：=>如果一个容器中的很多元素都需要绑定点击事件，我们不必逐一绑定，只给最外层容器绑定一个点击事件即可，点击方法执行时，通过区分事件源来进行不同的操作。
     =>之前自己封装过一个小的拖拽插件，其中部分需求的解决也是采用事件委托，实现拖拽元素和鼠标的绑定，解决了移动速度过快时，鼠标焦点丢失的问题
好处：
=>基于事件委托完成的事件绑定比普通单独绑定提高50%的性能
=>可以给动态的元素绑定点击事件。jQ中的delegate可以完成事件委托并且不需要判断事件源


4. localStorage和cookie的区别，cookie和session的关系！
相同点：
都是本地存储的方式；
都是本地明文存储，不安全。

不同点：
=>存储大小：同源下每条cookie的存储大小为4KB；localStorage的存储大小为5MB
=>时效性：cookie有过期时间，一般自己手动设置，时间不会设置过长（使用360卫士等或者浏览器自带的清理软件清理垃圾都可能会清理掉cookie）；localStorage，不手动清除会永久保存在本地
=>兼容：cookie兼容所有浏览器；localStorage不兼容IE低版本浏览器
=>是否支持手动禁用：处于安全考虑，用户可能手动禁用cookie(无痕浏览器)；localStorage无法禁止
=>处理机制：cookie不是完全的本地存储，使用cookie时，需要客户端和服务器端信息的通信;localStorage完全的本地存储

cookie和session关系：
cookie是实现session的一种方式，是session的一种后端无状态的实现。
session的运行依赖session id，而session id是存在cookie中的。
例如：客户端在发送一个请求路径后，服务器端响应信息，并在第一次响应时即在响应内容中添加一个session id，
以后客户端每次请求时，都会带着这个标识，服务器端借助session id来识别不同用户的访问以及区分会话



5. 什么是闭包，你在项目中哪一块用到了闭包！
=>含义
函数执行时形成一个不销毁的栈内存，保护里面的变量不受外界干扰，同时也可以保存一些内容，把私有作用中的东西暴露到函数外面使用，
我们把函数执行形成的这种保护和保存机制称为闭包。

=>作用及应用
保存：形成的私有作用域在函数执行完成一般会自动释放销毁，但是当栈内存中的内容被栈内存以外的东西占用，则此栈内存不销毁，形成不销毁的栈内存，里面的私有变量也不销毁，
     基于闭包的保护机制，实现的高级单例模式
保护：形成私有作用域，保护里面的私有变量不受外界干扰，真实项目中基于闭包的保护机制，实现团队协作开发（避免了多人同名、全局变量污染等问题）


6. js中定义函数的方式有哪些，区别是什么！
方式：
函数声明式：基于function关键字，显式定义函数：function(){}
函数表达式方式：let fn=function(){}
基于Function构造函数定义：let f=new Function()
？？？？基于ES6语法，创建箭头函数：let fn=()=>{}

区别：
=>函数声明式一般用于ES5中定义函数，存在变量提升，可以在声明之前执行；函数表达式方式一般用于ES6中定义函数，不存在变量提升，只能在定义完后执行。
因为，解析器在解析时，会优先解析函数声明式，使其在执行任何代码前可访问，而表达式方式定义的函数，必须等到解析器执行到它所在的代码行，才会被解释执行
=>构造函数方式定义会导致解析两次代码，影响性能。第一次解析常规的js代码，第二次解析传入构造函数的字符串。这种方式对于理解‘函数是对象，函数名是指针，还是非常直观的’


7. 说出你掌握的继承方式及优缺点，并加以改进！
=>继承方式：
原型继承：让子类的原型指向父类的实例，把父类公有和私有的方法都继承给子类作为子类公有的方法
call继承：把父类当作普通函数放到子类中执行，修改函数中的this
寄生组合式继承：把父类当作函数在子类中执行，修改函数中的this为子类的实例，用Object.create创建空对象，并把传入的参数当作空对象的原型，把子类的原型指向空对象的原型
ES6中的继承：相当于寄生组合式继承

=>优缺点：
原型继承：
1)实质就是增加了子类和父类之间原型链的链接关系,子类实例想访问父类的方法，直接利用原型链的查找机制逐级向上查找即可
2）=>如果父类的一个属性是引用数据类型，创建子类的一个实例f，当我们通过f修改子类共有的这个属性时，其他子类的实例也会受到影响
   =>不能向父类的构造传参数，父类给其实例定义的私有属性的值和传入的参数有关系，子类继承过来之后，所有子类实例共有属性的值都是一样的
   =>子类的原型直接指向父类的实例导致子类的constructor丢失，需要手动添加

call继承：
1)把父类私有的属性和方法克隆一份一模一样的作为子类私有的属性，
2）父类共有的无法继承

寄生组合式继承：
1）实现了子类公有继承父类公有，子类私有继承父类私有，并且子类还可以扩展自己实例的共有属性和方法

ES6中的类和继承：和寄生组合式继承的优势体现一致



8. 说出ES6和ES5的区别！





9. 阐述JS中的同步编程和异步编程，以及你在项目中是如何来使用异步操作的！
10. 实现一个Promise

### HTTP && AJAX && 跨域 （18+玩家必备技能，初级玩家需要了解一些的）
1. 写出项目中经常用到的性能优化方案
2. 从浏览器地址栏输入URL到显示页面，中间都经历了什么（尽可能写详细，最好回答出TCP的三次握手和四次挥手，以及浏览器加载页面的细节）
3. 说出你所熟知的HTTP状态码！GET和POST有啥区别！
4. 什么是HTTP报文，你熟知的报文都有哪些！
5. 能说下304具体怎样实现吗？
6. 跨域是什么？http协议中如何判断跨域？如何解决跨域问题？
7. HTTP2具体内容？SDPY了解么？
8. HTTPS如何实现？tsl/ssl是什么？对称加密、非对称加密在什么时候、对什么数据加密？
9. DNS劫持是什么？
10. 封装一个AJAX库！